[Главная](../index) → Концепции → *Стороны*<br>
<small>[← Назад](../Getting_Started/Debug_Profiler "Начало работы: Отладочный профилировщик") | [Далее →](Resources "Концепции: Ресурсы")</small>

---

- [**Стороны**](#Sides)
  + [Различные типы сторон](#Different_Kinds_of_Sides)
  + [Выполнение операций на одной стороне](#Performing_Side-Specific_Operations)
    - [Поле `world.isRemote`](#world_isRemote)
	- [Класс `DistExecutor`](#DistExecutor)
	- [Группы потоков](#Thread_Groups)
	- [`FMLEnvironment.dist` и `@OnlyIn`](#FMLEnvironment.dist_and_OnlyIn)
  + [Распространённые ошибки](#Common_Mistakes)
    - [Доступ к другой логической стороне](#Reaching_Across_Logical_Sides)
  + [Написание «односторонних» модификаций](#Writing_One-Sided_Mods)

---

# <a name="Sides"></a>Стороны
Стороны (sides): *клиент* и *сервер* — концепция, которая очень важна для понимания разработчиком модификации. Существует очень много ошибок, связанных с неправильным пониманием этих сторон. Эти ошибки могут и не привести к аварийному завершению игры, но способны вызвать непреднамененные и часто непредсказуемые эффекты.

## <a name="Different_Kinds_of_Sides"></a>Различные типы сторон
Когда мы говорим «клиент» или «сервер», мы обычно интуитивно представляем, о какой части игры идёт речь. В конце концов, клиент — это то, с чем пользователь взаимодействует, а сервер — то, где он подключается к сетевой игре. Несложно, верно?

Оказывается, даже у таких двух терминов может существовать неоднозначность. Здесь мы устраним её, определив четыре возможных значения «клиента» и «сервера».

- **Физический клиент** (physical client) — вся программа, которая начинает работать каждый раз, когда Вы запускаете Minecraft из лаунчера. Все потоки, процессы и службы, связанные с графикой, взаимодействием, — всё это часть физического клиента.
- **Физический сервер** (physical server), называемый также выделенным (dedicated) — вся программа, которая начинает работать каждый раз, когда Вы запускаете любого рода `minecraft_server.jar`, не имеющий графического интерфейса, предназначенного для игры.
- **Логический сервер** (logical server) — это то, где происходит вся игровая логика: спаун мобов, погода, обновление инвенторей, здоровье, ИИ и все остальные игровые механики. Логический сервер существует внутри физического сервера, но в одиночной игре запускается внутри физического клиента. Логический сервер всегда работает в потоке под названием `Server Thread`.
- **Логический клиент** (logical client) — то, что принимает от игрока команды и передаёт их логическому серверу. Кроме того, он принимает информацию от логического сервера и предоставляет её игроку в графическом виде. Логический клиент работает в потоке `Client Thread`, хотя нередко создаются некоторые другие потоки для обработки таких вещей, как звук или прорисовка чанков.

В коде Minecraft физическая сторона представлена в перечислении (enum) под названием `Dist`, а логическая — `LogicalSide`.

## <a name="Performing_Side-Specific_Operations"></a>Выполнение операций на одной стороне

### <a name="world_isRemote"></a>Поле `world.isRemote`
Это булево поле будет Вашим наиболее часто используемым способом проверить сторону. Его значение в объекте класса `World` определяет **логическую** сторону, на которой находится мир. То есть если значение поля равно `true`, то мир в данный момент работает на логическом клиенте, если `false` — на логическом сервере. Из этого следует, что на физическом сервере в этом поле всегда будет содержаться `false`. Однако это же значение может быть и на физическом клиенте, в котором находится логический клиент в одиночной игре.

Используйте эту переменную всякий раз, когда Вам необходимо определить, должна ли выполняться какая-либо игровая логика или иная механика. Например, если Вы хотите наносить игроку урон каждый раз, когда он кликает по блоку, или запустить свою машину по превращению земли в алмазы, Вы должны делать это только после того, как убедитесь, что `world.isRemote` равно `false`. Выполнение игровой логики на логическом клиенте может вызвать в лучшем случае рассинхронизацию (призрачные сущности, различные значения здоровья и голода на клиенте и сервере и т. д.), а в худшем — аварийное завершение игры.

Это поле следует использовать «по умолчанию». Редко будут возникать ситуации, когда для проверки стороны и определения поведения Вам понадобятся какие-либо способы, кроме `world.isRemote` и `DistExecutor`.

### <a name="DistExecutor"></a>Класс `DistExecutor`
Учитывая, что и для клиента, и для сервера используется один и тот же jar-файл, в то время как физические стороны разделены на два jar-файла, возникает важный вопрос: как использовать код, который предназначен только для одной физической стороны? Весь код в пакете `net.minecraft.client` предназначен только для физического клиента, а в `net.minecraft.server.dedicated` — для физического сервера. Если Ваш класс будет любым способом ссылаться на содержимое этих пакетов, то как только он будет загружен в окружение, где данных имён не существует, произойдёт аварийное завершение игры. Очень распространённой среди начинающих ошибкой является вызов `Minecraft.getMinecraft().<метод>()` из класса блоков или блок-сущностей, что приводит к ошибке на физическом сервере сразу же после загрузки класса.

Как мы можем решить эту проблему? К счастью, FML (Forge Mod Loader — загрузчик модификаций Forge) имеет `DistExecutor`, содержащий методы, позволяющие запускать разные функции на разных физических сторонах или же запускать какую-то конкретную функцию только на одной стороне.

> <big>**Примечание**</big>
>
> Важно понимать, что FML проверяет только **физическую** сторону. В одиночной игре (логический сервер и логический клиент на физическом клиенте) всегда используется `Dist.CLIENT`!

### <a name="Thread_Groups"></a>Группы потоков
Если выражение `Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER` истинно, скорее всего, текущий поток работает на логическом сервере. В противном случае текущий поток, скорее всего, запущен на логическом клиенте. Этот метод позволяет определить **логическую** сторону, когда доступа к объекту `World` для проверки `isRemote` нет. С его помощью можно *предположить*, на какой логической стороне Вы находитесь, основываясь на группе, к которой принадлежит текущий поток. Поскольку это лишь предположение, данный метод следует использовать только тогда, когда другие способы по какой-либо причине не могут быть применены. Практически во всех случаях Вам следует отдавать предпочтение проверке поля `World.isRemote`.

### <a name="FMLEnvironment.dist_and_OnlyIn"></a>`FMLEnvironment.dist` и `@OnlyIn`
`FMLEnvironment.dist` содержит **физическую** сторону, на которой работает Ваш код. Поскольку значение этого поля определяется при запуске, оно не является предположением. Впрочем, число случаев, когда следует применять этот способ, ограничено.

Аннотация `@OnlyIn(Dist)` сообщает загрузчику, что помеченный ей член класса (метод или поле) должен быть оставлен в определении исключительно на соответствующей **физической** стороне. Обычно эти аннотации можно найти только при просмотре декомпилированного кода Minecraft у методов, которые были вырезаны обфускатором Mojang. Не существует практически ни одной причины использовать данную аннотацию напрямую. Применяйте её только тогда, когда перезаписываете встроенные методы, уже имеющие `@OnlyIn`. В большинстве других случаев, когда Вам необходимо определить поведение программы в зависимости от физической стороны, используйте `DistExecutor` или поле `FMLEnvironment.dist`.

## <a name="Common_Mistakes"></a>Распространённые ошибки

### <a name="Reaching_Across_Logical_Sides">Доступ к другой логической стороне</a>
Каждый раз, когда Вы хотите передать информацию с одной логической стороны на другую, Вы должны **всегда** использовать сетевые пакеты (network packets). Невероято заманчивой является передача данных напрямую с логического сервера на логический клиент в одиночной игре.

На самом деле, это очень часто непреднамененно делается с использованием статических полей. Поскольку в одиночной игре логический клиент и логический сервер используют одну и ту же JVM (виртуальную машину Java), запись и чтение статического поля двумя потоками приведёт к различного рода состояниям гонки (race conditions) и классическим проблемам, связанным с многопоточностью.

Эта ошибка может также быть допущена явно, если Вы обращаетесь к классам, досупным только для физических клиентов, (например, `Minecraft`), из общего кода, который запущен или может быть запущен на логическом сервере. Данная ошибка может быть легко пропущена новичками, проводящими отладку на физическом клиенте. Там код заработает, но на физическом сервере будет немедленно вызывать аварийное завершение игры.

## <a name="Writing_One-Sided_Mods"></a>Написание «односторонних» модификаций
В последних версиях Minecraft Forge из файла mods.toml был удалён аттрибут «sidedness». Это означает следующее: предполагается, что Ваша модификация будет работать, где бы её ни загрузили: и на клиенте, и на сервере. В «односторонних» (one-sided) модификациях Вы обычно регистрируете свои обработчики событий (event handlers) в `DistExecutor.runWhenOn`, вместо вызова соответствующих методов регистриции в конструкторе. Вообще говоря, если Ваша модификация запущена на неверной стороне, она просто не должна ничего делать, в частности, не обрабатывать события. «Односторонние» модификации не должны регистрировать блоки, предметы и прочее, поскольку все они должны быть также доступны и на другой стороне.

Кроме того, «односторонние» модификации обычно не должны запрещать игроку подключаться к серверу, на котором этот мод отсутствует. Поэтому Вам следует перезаписать точку расширения (extension point) `DISPLAYTEXT`, чтобы Forge не считал Вашу модификацию необходимой на сервере, из-за чего сервер отображался бы как неподдерживаемый. Для этого поместите в конструктор главного класса модификации что-то наподобие этого:

```java
// С этой строкой отсутствие модификации на другой сетевой стороне не приведёт к тому, что клиент пометит сервер как неподдерживаемый
ModLoadingContext.get().registerExtensionPoint(ExtensionPoint.DISPLAYTEST, () -> Pair.of(() -> FMLNetworkConstants.IGNORESERVERONLY, (a, b) -> true));
```

Это сообщает клиенту, что он должен игнорировать отсутствие модификации на сервере, а серверу — что он не должен сообщать клиенту об отсутствии мода. Таким образом, эта строка работает как внутри «серверных», так и внутри «клиентских» «односторонних» модификаций.


---

<small>[← Назад](../Getting_Started/Debug_Profiler "Начало работы: Отладочный профилировщик") | [Далее →](Resources "Концепции: Ресурсы")</small>
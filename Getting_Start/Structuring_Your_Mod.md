[Главная](../Home) → Начало работы → Структура Вашей модификации<br>
<small>[← Назад](Home "Начало работы: Введение") | [Далее →](Forge_Update_Checker "Начало работы: Проверка обновлений с Forge")</small>

---

- [Структура Вашей модификации](#Structuring_Your_Mod)
  - [Пакеты](#Packaging)
  - [Файл `mods.toml`](#The_mods.toml_File)
  - [Файл модификации](#The_Mod_File)
  - [Что такое `@Mod`?](#What_is_@Mod?)
  - [Делаем код чистым, используя подпакеты](#Keeping_Your_Code_Clean_Using_Sub-packages)
  - [Принципы именования классов](#Class_Naming_Schemes)

---

# <a name="Structuring_Your_Mod"></a>Структура Вашей модификации
Рассмотрим, как распределить Вашу модификацию по файлам и что эти файлы должны делать.

## <a name="Packaging"></a>Пакеты
Выберите уникальное имя пакета. Если у Вас есть URL, связанный с проектом, Вы можете использовать его в качестве имени для пакета верхнего уровня. Например, Вы владеете URL «example.com»; тогда можете использовать `com.example` как верхний уровень в названии пакета.

> **ВАЖНО**
>
> Если у Вас нет своего домена, не используйте его в качестве имени пакета верхнего уровня. Вполне возможно начать это имя с чего угодно, например, Вашего никнейма или названия модификации.

После названия пакета верхнего уровня введите уникальное имя модификации, к примеру, `examplemod`. В нашем случае пакет будет иметь название `com.example.examplemod`.

<small>Чтобы создать пакет в IntelliJ IDEA, перейдите на вкладку «Project» («Проект») слева и убедитесь, что в верхней части этой вкладки установлен режим «Project». Далее найдите там папку `src/main/java` и нажмите по ней правой кнопкой мыши. Выберите «New» → «Package» («Создать» → «Пакет») и в открывшемся окне введите название пакета. Подвердите его клавишей Enter.</small>

## <a name="The_mods.toml_File"></a>Файл `mods.toml`
Этот файл определяет метаданные Вашей модификации. Эту информацию могут увидеть игроки, если в главном меню нажмут кнопку «Моды» («Mods»). Один подобный файл может описывать несколько модификаций.

Файл `mods.toml` пишется на языке разметки [TOML](https://github.com/toml-lang/toml), в примере файла mods.toml в MDK есть комментарии на английском языке, объясняющие его содержимое. Этот файл должен находиться по адресу `src/main/resources/META-INF/mods.toml` Простейший `mods.toml`, описывающий одну модификацию, может выглядеть примерно так:

```toml
# Название типа загрузчика модификаций. Для обычных FML @Mod модов должен использоваться загрузчик javafml
modLoader="javafml"
# Диапазон версий для загрузчика модификаций. Для обычных FML @Mod модов тут нужно указать версию Forge.
# Forge для 1.16.3 имеет версию 34
loaderVersion="[34,)"
# URL сайта, где люди могут сообщать об ошибках в модификации
issueTrackerURL="github.com/MinecraftForge/MinecraftForge/issues"
# Должны ли модификации, определяемые в этом файле, отображаться как отдельные пакеты ресурсов
showAsResourcePack=false

[[mods]]
  modId="examplemod"
  version="1.0.0.0"
  displayName="Example Mod"
  updateJSONURL="minecraftforge.net/versions.json"
  displayURL="minecraftforge.net"
  logoFile="assets/examplemod/textures/logo.png"
  credits="Я хотел бы сказать спасибо своей маме и папе."
  authors="Автор"
  description='''
  Позволяет крафтить алмазы из земли. Это традиционный мод, который существует уже целую вечность. Он древний. Святой Нотч создал его. Джеб сделал его радужным. Диннербон перевернул его вверх ногами. И т. д.
  '''

  [[dependencies.examplemod]]
    modId="forge"
    mandatory=true
    versionRange="[34,)"
    ordering="NONE"
    side="BOTH"

  [[dependencies.examplemod]]
    modId="minecraft"
    mandatory=true
    versionRange="[1.16.3]"
    ordering="NONE"
    side="BOTH"
```

Gradle по умолчанию заменяет `${file.jarVersion}` на версию проекта, но *только* в файле `mods.toml`. Лучше использовать эту возможность, а не вводить версию напрямую. Ниже приведена таблица свойств, которые могут быть присвоены модификации. В ней `обязательное` означает, что у свойства нет значения по умолчанию, а его отсутствие вызовет ошибку.

|      Свойство |  Тип   | По умолчанию | Описание |
| -------------:|:------:|:------------:| -------- |
|         modid | строка | обязательное | Id модификации, которую описывает этот файл.
|       version | строка | обязательное | Версия модификации. Лучше записывать её как числа, разделённые точками, в идеале запись должна соответствовать соглашению «[Semantic Versions](https://semver.org/)».
|   displayName | строка | обязательное | Название модификации, которое пользователь увидит в списке модов.
| updateJSONURL | строка |     `""`     | URL JSON-файла версии (см. раздел «[Проверка обновлений с Forge](Forge_Update_Checker)».
|    displayURL | строка |     `""`     | Ссылка на главную страницу модификации.
|      logoFile | строка |     `""`     | Название файла с логотипом модификации. Он должен быть расположен прямо в папке `resources`, не в подпапках.
|       credits | строка |     `""`     | Строка, содержащая любые благодарности, которые Вы хотели бы выразить.
|       authors | строка |     `""`     | Авторы модификации.
|   description | строка | обязательное | Описание модификации.
|  dependencies | список |     `[]`     | Список зависимостей модификации.

\*Все диапазоны версий указываются согласно [правилам указания диапазонов версий Maven](https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html).

## <a name="The_Mod_File"></a>Файл модификации
Как правило, мы начинаем с файла, названного в честь Вашей модификации и помещённого в Ваш пакет <small>(в IntelliJ IDEA ПКМ по пакету, затем «New» → «Java Class» \[«Создать» → «Класс Java»\]; в открывшемся окне нужно ввести название, например, `ExampleMod`).</small>. Это *точка входа* (*entry point*) в модификацию; чтобы обозначить это, файл должен содержать некоторые особые маркеры.

## <a name="What_is_@Mod?"></a>Что такое `@Mod`?
Это аннотация, сообщающая загрузчику модификаций Forge (Forge Mod Loader), что данный класс является точкой входа. Значение аннотации `@Mod` должно содержать id модификции, указанный в файле `src/main/resources/META-INF/mods.toml`.

## <a name="Keeping_Your_Code_Clean_Using_Sub-packages"></a>Делаем код чистым, используя подпакеты
Вместо того чтобы загромождать единственный класс или пакет всем, что есть, рекомендуется разбивать Вашу модификацию на подпакеты. Обычно мод делят на пакеты `common` (общее) и `client` (клиент), которые содержат код для клиента и сервера (`common`) и только для клиента (`client`). В пакете `common` содержатся такие вещи как предметы, блоки и блок-сущности (Tile entities) (для каждого из этих типов может быть создан собственный подпакет). Графические интерфейсы (GUIs) и отрисовщики (Renderers) следует помещать в пакет `client`.

> **Примечание**
>
> Этот стиль разделения на пакеты — лишь предложение, хоть он и является самым используемым. При желании Вы можете спокойно использовать свою собственную систему.

Правильно распределяя свой код по пакетам, Вы сможете развивать модификацию со значительно большим удобством.

## <a name="Class_Naming_Schemes"></a>Принципы именования классов
Единый принцип именования классов позволяет проще определить, чем является класс, а также даёт другим разработчикам возможность легче находить нужные вещи.

Например:
- Предмет (`Item`) под названием `PowerRing` («энергетическое кольцо») расположен в пакете `item` в классе `PowerRingItem`.
- Блок (`Block`) под названием `NotDirt` («не земля») расположен в пакете `block` в классе `NotDirtBlock`.
- Наконец, блок-сущность (`TileEntity`) под названием `SuperChewer` («супержвачка») расположена в пакете `tile` или `tileentity` в классе `SuperChewerTile`.

Добавление к названию класса *типа* объекта, который он определяет, позволяет легче понимать, чем он является, а также находить нужный класс.

---

<small>[← Назад](Home "Начало работы: Введение") | [Далее →](Forge_Update_Checker "Начало работы: Проверка обновлений с Forge")</small>